> 原文[Compiler and Engines presentation](https://www-verimag.imag.fr/TOOLS/DCS/bip/doc/latest/html/compiler-engines-presentation.html)

# 编译器和引擎概述

## 编译器

编译器由三部分组成，将在以下各节中更详细地介绍:

* *前端*（*front-end*）: 它与编译器的用户交互。它读取用户输入并将其转换为适合以下过程的形式（即内部表示，internal representation，IR）。
* *中端*（*middle-end*）: 对使用了内部表示的应用进行操作（例如优化、体系结构转换等）。其中有一个这样的操作包含在编译器中的一个小*块*（*block*）中，稍后我们将称其为*过滤器*（*filter*）。
* *后端*（*back-end*）：从内部表示产生最终结果。通常以编程语言中的源代码的形式（例如C++）呈现。可以同时使用多个后端。

<div align=center> <img alt="compiler-presentation.png"
                        src="https://www-verimag.imag.fr/TOOLS/DCS/bip/doc/latest/html/_images/compiler-presentation.png"/> </div> 编译器设计概述

典型的编译包括以下步骤:

* 首先，前端运行并产出 *BIP-EMF* 模型；
* 然后，中端的过滤器依次执行，结果是一个可能经过了修改BIP-EMF模型；
* 最后，依次执行所有后端，它们的运行结果即编译结果。

### 前端

此部分负责读取用户输入（即，BIP 源代码和命令行参数），并将其转换为中间表示形式，该表示形式将在编译器的其他部分中使用。当前的前端包括一个用于 BIP 语言的解析器和一个描述中间表示的 BIP 元模型（meta-model）。在 BIP 元模型中表示的 BIP 模型的实例称为 *BIP-EMF 模型*（因为这是一个使用 [Eclipse Modeling Framework](http://www.eclipse.org/emf) (EMF)技术表达的 BIP 模型）。有关内部结构的详细信息，请参阅前端。

#### 类型模型与实例模型

BIP 语言只处理*类型*（*type*）。BIP 不支持运行时实体，即使最终建模结果应该是一个正在运行的系统。这些*缺失*（*missing*）的信息通常通过在编译时指定*根*（*root*）组件来填充。编译器（即前端）能够建立两个类型模型，一个是类型模型（如作为输入的 BIP 源码的表示），另一个是要运行的系统的*实例*（*instance*）模型。两者之间的区别可能是微妙的，特别是当*声明*的概念混合在两者之间时：

* 组件类型描述该类型的实例的*形态*（*shape*）；
* 组件声明指导组件类型的实例的创建；
* 组件实例是一个运行中（*running*）实体。

这些概念类似于面向对象语言中的类/实例/对象声明。例如在 Java 中：

* 组件类型 = 类

  ```
  public class MyClass { ... }
  ```

* 组件（组件类型的实例） = 对象（类的实例）

  ```
  new MyClass();
  ```

* 组件声明 = 对象声明

  ```
  MyClass m;
  ```

请注意，一个组件声明可以触发多个实例的创建。组件声明通常不是整个系统中的判别组件的标识符。

### 中端

中端承载所有从 BIP 到 BIP 的转换（*transformation*）。中端通过下列操作作用于 *BIP-EMF*：

* 架构修改（如展平，组件注入等）；
* Petri 网简化；
* 死锁移除；
* 数据收集。

当中端为空时，当前的编译器不进行任何上述的操作:。参考 中端 获取更多信息。

### 后端

后端获取 BIP-EMF 模型，并且读取它并生成某些内容，最有可能的内容是一些其他语言的源代码（例如，C, C++, Aseba等）甚至是 BIP 代码本身。目前主要使用的后端是 C++ 后端，它生成适合于标准引擎的 C++ 代码（标准引擎的定义参见 安装和使用可用的引擎 部分 ）。

可以同时使用多个后端；例如，为与您的输入对应的 C++  版本进行优化之后，您可能需要获得相应优化后的 BIP 版本。编译器的设计禁止了与后端之间的交互（当有多个后端要执行时，编译器没有指定它们将以何种顺序运行，或者执行是否并行）。

## 引擎

引擎接受 BIP 模型的某种表示，并根据 BIP 语义计算相应的执行序列。通常，所使用的表示是一个 C++ 软件，它与引擎的运行时链接以创建一个可执行软件。通常，引擎针对下列一个或多个主要目标:

* 模型的*执行*（*execution*）对应于意图要在目标平台上执行的单个执行序列的计算。在这种情况下，引擎实现模型和目标平台之间的连接，以确保执行在时间和输入/输出数据（通过传感器/执行器）方面的行为正确性。
* 模型的*仿真*（*simulation*）对应于一个单独的执行序列的计算，这个执行序列是出于仿真的目的而在主机上执行的，也就是说，时间以逻辑的方式被解释。
* 模型的*探索*（*exploration*）对应于若干个执行序列的计算，这些执行序列对应于模型中的多次仿真。模型的模型检查需要由语义应用定义的执行序列的完全覆盖，但是部分覆盖足以进行验证或统计模型检查。

## 引擎与编译器之间的交互

通常来说，后端通过 BIP 模型生成源代码。然后，此源代码与称为*引擎*（*engine*）的运行时关联，该运行时负责根据 BIP 语义正确执行 BIP 模型。

生成的源代码可以被视为 BIP 模型的另一种表示形式（前提是 BIP 源代码中包含的信息没有被添加任何内容），这种另外的表现形式适应了一个给定的引擎（该引擎可以实现此语言的语义）的要求。

